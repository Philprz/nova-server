<!DOCTYPE html>
<html lang="fr" role="document">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="NOVA ‚Äì Assistant Commercial Intelligent, g√©n√©ration automatique de devis.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOVA - Assistant Commercial Intelligent</title>
    <link
        href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css"
        rel="stylesheet"
        crossorigin="anonymous"
    >
    <link
        href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.10.0/font/bootstrap-icons.min.css"
        rel="stylesheet"
        crossorigin="anonymous"
    >
    <style>
        :root {
            --primary-blue: #02B9FD;
            --primary-violet: #832DFE;
            --accent-color: #E220FB;
            --success-color: #2DFE83;
            --warning-color: #FD5202;

            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --border-color: #dee2e6;
            --shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .client-selection-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .client-selection-button {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
        }
        .client-selection-button .client-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .client-selection-button .client-source {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .client-selection-button .client-details {
            font-size: 12px;
            line-height: 1.4;
            opacity: 0.9;
            text-align: left;
        }
        
        .client-selection-button:hover .client-details {
            opacity: 1;
        }
        .client-selection-button:hover {
            background-color: var(--bg-primary);
            border-color: var(--primary-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }

        .client-selection-button strong {
            font-weight: 600;
            color: var(--primary-blue);
        }

        .client-selection-button small {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .client-selection-button.create-new {
            color: var(--success-color);
            border-style: dashed;
            align-items: center;
            flex-direction: row;
            gap: 8px;
        }

        .client-selection-button.create-new:hover {
            color: white;
            background-color: var(--success-color);
            border-color: var(--success-color);
        }

        /* Styles pour la s√©lection de produit */
        .product-selection-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
        }

        .product-selection-button {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
        }

        .product-selection-button .product-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .product-selection-button .product-details {
            font-size: 12px;
            line-height: 1.4;
            opacity: 0.9;
            text-align: left;
        }

        .product-selection-button:hover .product-details {
            opacity: 1;
        }

        .product-selection-button:hover {
            background-color: var(--bg-primary);
            border-color: var(--primary-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }

        .product-selection-button strong {
            font-weight: 600;
            color: var(--primary-blue);
        }

        .product-selection-button.create-new {
            color: var(--success-color);
            border-style: dashed;
            align-items: center;
            flex-direction: row;
            gap: 8px;
        }

        .product-selection-button.create-new:hover {
            color: white;
            background-color: var(--success-color);
            border-color: var(--success-color);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000000;
            color: var(--text-primary);
            line-height: 1.6;
        }

        .main-container {
            width: 800px;
            margin: 0 auto;
            min-height: 100vh;
        }


/*MARINA*/
        .header {
            background: var(--bg-primary);
  border-radius: 8px;
  padding: 0px 24px 0px 24px;
  margin-bottom: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
        }


/*MARINA*/
        .chat-container {
            background: #0b1b29;
            border-radius: 8px;
            box-shadow: var(--shadow);
            height: 70vh;
            display: flex;
            flex-direction: column;
            border: 1px solid #832DFE;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px 0;
            margin-bottom: 20px;
        }

        .message {
            margin-bottom: 16px;
            padding: 12px 16px;
            border-radius: 6px;
            max-width: 85%;
            border: 1px solid var(--border-color);
        }

        .message.user {
            background: var(--primary-blue);
            color: white;
            margin-left: auto;
            border: none;
        }

        .message.assistant {
            background: var(--bg-secondary);
            margin-right: auto;
        }

        .message.system {
            /* Option 1: Couleur actuelle (gris clair) */
            /* background: var(--bg-tertiary); */

            /* Option 2: Bleu tr√®s clair */
            /* background: rgba(2, 185, 253, 0.1); */

            /* Option 3: Violet tr√®s clair */
            /* background: rgba(131, 45, 254, 0.1); */

            /* Option 4: Vert tr√®s clair (succ√®s) */
            /* background: rgba(45, 254, 131, 0.1); */

            /* Option 5: Orange tr√®s clair (attention) */
            /* background: rgba(253, 82, 2, 0.1); */

            /* Option 6: Fond sombre pour contraste */
            /* background: #1a2332; color: #ffffff; */

            /* Option 7: D√©grad√© subtil */
            background: linear-gradient(135deg, rgba(2, 185, 253, 0.05) 0%, rgba(131, 45, 254, 0.05) 100%);

            margin: 0 auto;
            text-align: center;
            max-width: 100%;
            border-left: 3px solid var(--primary-blue);
        }

/*MARINA*/
        .welcome-message {
            text-align: center;
  padding: 4px;
  border-radius: 1px;
  margin-bottom: 4px;
        }
/*MARINA*/
        .welcome-title {
            font-size: 18px;
  font-weight: 500;
  color: #02B9FD;
  margin-bottom: 12px;
        }

        .welcome-subtitle {
            font-size: 1rem;
            color: var(--text-secondary);
        }

        .progress-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 16px;
            margin: 16px 0;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .progress-title {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .progress-percentage {
            font-size: 0.8rem;
            color: var(--primary-blue);
            font-weight: 600;
        }

        .progress-bar {
            background: var(--bg-tertiary);
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-blue);
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .progress-steps {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .progress-step {
            padding: 4px 8px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            transition: all 0.3s ease;
        }

        .progress-step.active {
            background: var(--primary-blue);
            color: white;
        }

        .progress-step.completed {
            background: var(--success-color);
            color: white;
        }

        .enrichment-panel {
            background: var(--bg-primary);
            border: 1px solid var(--warning-color);
            border-radius: 6px;
            padding: 16px;
            margin: 16px 0;
            display: none;
        }

        .enrichment-panel.active {
            display: block;
        }

        .enrichment-header {
            color: var(--warning-color);
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            font-size: 0.9rem;
        }

        .enrichment-header i {
            margin-right: 8px;
        }

        .enrichment-content {
            background: var(--bg-secondary);
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .enrichment-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .enrichment-item:last-child {
            border-bottom: none;
        }

        .enrichment-item strong {
            color: var(--text-primary);
        }

        .enrichment-item span:last-child {
            color: var(--text-secondary);
        }

        .typing-indicator {
            display: none;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 16px;
            max-width: 180px;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-content {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .typing-dots {
            display: flex;
            gap: 3px;
        }

        .typing-dot {
            width: 6px;
            height: 6px;
            background: var(--primary-blue);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }

        .input-container {
            display: flex;
            gap: 12px;
            align-items: flex-end;
            border-top: 1px solid #dee2e636;
            padding-top: 16px;
        }

        .chat-input {
            flex: 1;
            background: #0b1b29;
            border: 1px solid var(--border-color);
            border-radius: 26px;
            padding: 12px 16px;
            color: #ffffff;
            font-size: 0.9rem;
            resize: none;
            transition: border-color 0.2s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary-blue);
        }

        .send-button {
            background: linear-gradient(135deg, #02B9FD, #832DFE, #E220FB);
  border: none;
  border-radius: 30px;
  width: 52px;
  height: 52px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 1.1rem;
  cursor: pointer;
  transition: background-color 0.2s ease;
        }

        .send-button:hover:not(:disabled) {
            background: #0ea5e9;
        }

        .send-button:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
        }

        .suggestion-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }

        .suggestion-button {
            background: var(--bg-primary);
            border: 1px solid var(--primary-blue);
            border-radius: 20px;
            padding: 6px 12px;
            color: var(--primary-blue);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .suggestion-button:hover {
            background: var(--primary-blue);
            color: white;
        }

        .validation-actions {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }

        .validation-error {
            color: var(--warning-color);
            font-size: 0.875rem;
            margin-top: 8px;
            padding: 8px 12px;
            background-color: rgba(253, 82, 2, 0.1);
            border: 1px solid var(--warning-color);
            border-radius: 4px;
            display: none;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .send-button:disabled {
            opacity: 0.6 !important;
            cursor: not-allowed !important;
            pointer-events: none;
        }

        .chat-input:invalid {
            border-color: var(--warning-color);
            box-shadow: 0 0 0 2px rgba(253, 82, 2, 0.1);
        }

        .chat-input:valid {
            border-color: var(--success-color);
        }

        .input-container {
            position: relative;
        }

        .btn-primary {
            background: var(--primary-blue);
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .btn-primary:hover {
            background: #0ea5e9;
        }

        .btn-secondary {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 16px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-secondary:hover {
            border-color: var(--primary-blue);
            color: var(--primary-blue);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 0.75rem;
            font-weight: 500;
            z-index: 1000;
            box-shadow: var(--shadow);
        }

        .connection-status.connected {
            background: var(--success-color);
            color: white;
        }

        .connection-status.disconnected {
            background: var(--warning-color);
            color: white;
        }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-container {
                padding: 12px;
            }
                        
            .logo {
                font-size: 2rem;
            }
            
            .chat-container {
                height: 75vh;
                padding: 16px;
            }
            
            .message {
                max-width: 95%;
                font-size: 0.9rem;
            }
            
            .input-container {
                gap: 8px;
            }
            
            .send-button {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus"></div>

    <div class="main-container">
        <header class="header">
            <div style="display:flex;align-items:center;justify-content:center;gap:0px;flex-wrap:wrap;">
                <img src="/static/Covia_bann.png" alt="Covia_Banniere" style="height:200px;display:block;border-radius:8px;">
            </div>
            </header>

        <div class="chat-container">
            <div class="chat-messages" id="chatMessages" role="log" aria-live="polite">
                <div class="welcome-message">
                    <div class="welcome-title">Bonjour !
                    Demandez-moi de cr√©er un devis ou posez-moi vos questions.
                    </div>
                </div>
            </div>

            <div class="progress-container" id="progressContainer">
                <div class="progress-header">
                    <div class="progress-title" id="progressTitle">Traitement en cours...</div>
                    <div class="progress-percentage" id="progressPercentage">0%</div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-steps" id="progressSteps">
                    <div class="progress-step">Analyse</div>
                    <div class="progress-step">Validation</div>
                    <div class="progress-step">Recherche</div>
                    <div class="progress-step">Cr√©ation</div>
                </div>
            </div>

            <div class="enrichment-panel" id="enrichmentPanel">
                <div class="enrichment-header">
                    <i class="bi bi-info-circle"></i>
                    Client non trouv√© - Enrichissement automatique
                </div>
                <div class="enrichment-content" id="enrichmentContent">
                    <!-- Contenu enrichi g√©n√©r√© dynamiquement -->
                </div>
                <div class="validation-actions">
                    <button class="btn-primary" onclick="validateEnrichment()">
                        <i class="bi bi-check"></i> Valider et Cr√©er
                    </button>
                    <button class="btn-secondary" onclick="editClientData()">
                        <i class="bi bi-pencil"></i> Modifier
                    </button>
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator">
                <div class="typing-content">
                    <span>NOVA traite...</span>
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            </div>

            <form id="chatForm" class="input-container" novalidate>

                <textarea
                    id="chatInput"
                    class="chat-input"
                    placeholder="Exemple : Cr√©er un devis de 12 imprimantes 50ppm pour RONDOT..."
                    rows="1"
                    aria-label="Message"
                    required
                    minlength="3"
                    maxlength="1000"
                ></textarea>
                <button id="sendButton" type="submit" class="send-button" aria-label="Envoyer">
                    <i class="bi bi-send"></i>
                </button>
            </form>
        </div>
    </div>

    <script>
        // Variables globales
        let currentTaskId = null;
        let isProcessing = false;
        let progressInterval = null;
        let enrichmentData = null;
        let websocket = null;
        let reconnectInterval = null;
        let clientSelectionMode = false;
        let availableClients = [];
        let originalClientName = '';

        // Fonction de g√©n√©ration d'UUID compatible avec tous les navigateurs
        function generateUUID() {
            // V√©rifier si crypto.randomUUID est disponible (navigateurs modernes)
            if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                return crypto.randomUUID();
            }

            // Fallback pour les navigateurs plus anciens
            if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = crypto.getRandomValues(new Uint8Array(1))[0] & 15;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            // Fallback ultime pour les tr√®s anciens navigateurs
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        // Gestion des messages
        function addMessage(content, type = 'assistant') {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            if (type === 'user') {
                messageDiv.innerHTML = `<strong>Vous:</strong> ${content}`;
            } else {
                messageDiv.innerHTML = content;
            }
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function addSuggestions(suggestions) {
            const messagesContainer = document.getElementById('chatMessages');
            const suggestionsDiv = document.createElement('div');
            suggestionsDiv.className = 'suggestion-buttons';
            
            suggestions.forEach(suggestion => {
                const button = document.createElement('button');
                button.className = 'suggestion-button';
                button.textContent = suggestion;
                button.onclick = () => handleSuggestionClick(suggestion);
                suggestionsDiv.appendChild(button);
            });
            
            messagesContainer.appendChild(suggestionsDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function handleSuggestionClick(suggestion) {
            document.getElementById('chatInput').value = suggestion;
            sendMessage();
        }

        function addClientSelection(clients, originalClientName) {
            clientSelectionMode = true;
            availableClients = clients;

            const messagesContainer = document.getElementById('chatMessages');

            // Message d'explication
            addMessage(`Plusieurs clients correspondent √† "${originalClientName}". Veuillez s√©lectionner :`, 'system');

            // Cr√©er les boutons de s√©lection
            const selectionDiv = document.createElement('div');
            selectionDiv.className = 'client-selection-container';

            clients.forEach((client, index) => {
                const button = document.createElement('button');
                button.className = 'client-selection-button';
                
                // Construire les informations d√©taill√©es du client
                const details = client.details || {};
                let detailsHtml = '';
                
                // Afficher les d√©tails disponibles de fa√ßon structur√©e
                const clientInfo = [];
                
                if (details.phone && details.phone !== 'null' && details.phone !== null) {
                    clientInfo.push(`üìû ${details.phone}`);
                }
                
                if (details.address && details.address !== 'N/A' && details.address !== 'None') {
                    clientInfo.push(`üìç ${details.address}`);
                }
                
                if (details.city && details.city !== 'null' && details.city !== null) {
                    clientInfo.push(`üè¢ ${details.city}`);
                }
                
                if (details.siret && details.siret !== 'null' && details.siret !== null) {
                    clientInfo.push(`üè∑Ô∏è SIRET: ${details.siret}`);
                }
                
                if (details.sf_id && details.sf_id !== '') {
                    clientInfo.push(`üÜî SF: ${details.sf_id.substring(0, 8)}...`);
                }
                
                if (details.sap_code && details.sap_code !== '') {
                    clientInfo.push(`üíº SAP: ${details.sap_code}`);
                }
                
                // Construire le HTML avec les d√©tails
                detailsHtml = clientInfo.length > 0 ? 
                    `<div class="client-details">${clientInfo.join('<br>')}</div>` : 
                    '<div class="client-details">Aucun d√©tail disponible</div>';
                
                button.innerHTML = `
                    <div class="client-header">
                        <strong>${client.name}</strong>
                        <span class="client-source">${client.source || 'Inconnue'}</span>
                    </div>
                    ${detailsHtml}
                `;
                button.onclick = () => selectClient(client, index);
                selectionDiv.appendChild(button);
            });

            // Bouton pour cr√©er un nouveau client
            const newClientButton = document.createElement('button');
            newClientButton.className = 'client-selection-button create-new';
            newClientButton.innerHTML = `
                <i class="bi bi-plus-circle"></i> Cr√©er un nouveau client "${originalClientName}"
            `;
            newClientButton.onclick = () => createNewClient(originalClientName);
            selectionDiv.appendChild(newClientButton);

            messagesContainer.appendChild(selectionDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function selectClient(client, index) {
            clientSelectionMode = false;
            availableClients = [];

            addMessage(`Vous avez s√©lectionn√© : ${client.name}`, 'user');

            // Utiliser le currentTaskId global ou window.currentTaskId
            const taskId = currentTaskId || window.currentTaskId;

            if (!taskId) {
                console.error("‚ùå Pas de task_id disponible pour la s√©lection");
                addMessage("‚ùå Erreur: Session non initialis√©e. Veuillez r√©essayer.", 'system');
                return;
            }

            // V√©rifier l'√©tat du WebSocket
            const ws = websocket || window.websocket;

            if (ws && ws.readyState === WebSocket.OPEN) {
                const response = {
                    type: "user_response",
                    task_id: taskId,
                    data: {
                        response_type: "client_selection",
                        action: "select_existing",
                        client_id: client.id,
                        client_name: client.name,
                        selected_index: index,
                        selected_client: client
                    }
                };
                console.log("üì§ S√©lection client avec task_id:", taskId, response);
                ws.send(JSON.stringify(response));

                // Afficher la progression apr√®s envoi
                showProgress();
            } else if (!ws || ws.readyState === WebSocket.CLOSED) {
                console.error("‚ùå WebSocket ferm√©, tentative de reconnexion...");
                // Tenter de reconnecter
                if (taskId) {
                    connectWebSocket(taskId);
                    // R√©essayer apr√®s un d√©lai
                    setTimeout(() => selectClient(client, index), 1000);
                }
            } else if (ws && ws.readyState === WebSocket.CONNECTING) {
                console.log("‚è≥ WebSocket en cours de connexion, r√©essai dans 500ms...");
                setTimeout(() => selectClient(client, index), 500);
            } else {
                console.error("‚ùå WebSocket non disponible");
                addMessage("‚ùå Erreur de connexion. Veuillez r√©essayer.", 'system');
            }
        }

        function createNewClient(clientName) {
            clientSelectionMode = false;
            availableClients = [];

            addMessage(`Vous avez choisi de cr√©er un nouveau client : "${clientName}"`, 'user');

            // Utiliser le currentTaskId global ou window.currentTaskId
            const taskId = currentTaskId || window.currentTaskId;

            if (!taskId) {
                console.error("‚ùå Pas de task_id disponible pour la cr√©ation");
                addMessage("‚ùå Erreur: Session non initialis√©e. Veuillez r√©essayer.", 'system');
                return;
            }

            // V√©rifier l'√©tat du WebSocket
            const ws = websocket || window.websocket;

            if (ws && ws.readyState === WebSocket.OPEN) {
                const response = {
                    type: "user_response",
                    task_id: taskId,
                    data: {
                        response_type: "client_selection",
                        action: "create_new",
                        client_name: clientName
                    }
                };
                console.log("üì§ Cr√©ation nouveau client avec task_id:", taskId, response);
                ws.send(JSON.stringify(response));

                // Afficher la progression apr√®s envoi
                showProgress();
            } else if (!ws || ws.readyState === WebSocket.CLOSED) {
                console.error("‚ùå WebSocket ferm√©, tentative de reconnexion...");
                // Tenter de reconnecter
                if (taskId) {
                    connectWebSocket(taskId);
                    // R√©essayer apr√®s un d√©lai
                    setTimeout(() => createNewClient(clientName), 1000);
                }
            } else if (ws && ws.readyState === WebSocket.CONNECTING) {
                console.log("‚è≥ WebSocket en cours de connexion, r√©essai dans 500ms...");
                setTimeout(() => createNewClient(clientName), 500);
            } else {
                console.error("‚ùå WebSocket non disponible");
                addMessage("‚ùå Erreur de connexion. Veuillez r√©essayer.", 'system');
            }
        }

        function continueWithSelectedClient(client) {
            addMessage(`Reprise du traitement avec le client : ${client.name}`, 'system');
            showProgress();
        }

        function continueWithNewClient(clientName) {
            addMessage(`Cr√©ation du nouveau client "${clientName}" en cours...`, 'system');
            showProgress();
        }

        // Fonction pour g√©rer la s√©lection de produit
        function handleProductSelection(data) {
            console.log("üì¶ S√©lection de produit requise:", data);

            const products = data.products || data.product_options || [];
            const searchTerm = data.search_term || data.product_name || '';

            // Afficher le message syst√®me
            if (searchTerm) {
                addMessage(`Recherche de produits pour "${searchTerm}". Voici les produits disponibles :`, 'system');
            } else {
                addMessage(`Voici les produits disponibles :`, 'system');
            }

            // Cr√©er le conteneur de s√©lection
            const messagesContainer = document.getElementById('chatMessages');
            const selectionDiv = document.createElement('div');
            selectionDiv.className = 'product-selection-container';

            // Afficher chaque produit
            products.forEach((product, index) => {
                const button = document.createElement('button');
                button.className = 'product-selection-button';

                // Construire les d√©tails du produit
                let productInfo = [];

                if (product.sku || product.code) {
                    productInfo.push(`üè∑Ô∏è Code: ${product.sku || product.code}`);
                }

                if (product.price) {
                    productInfo.push(`üí∞ Prix: ${product.price}‚Ç¨`);
                }

                if (product.unit) {
                    productInfo.push(`üìè Unit√©: ${product.unit}`);
                }

                if (product.description) {
                    productInfo.push(`üìù ${product.description}`);
                }

                const detailsHtml = productInfo.length > 0 ?
                    `<div class="product-details">${productInfo.join('<br>')}</div>` :
                    '<div class="product-details">Aucun d√©tail disponible</div>';

                button.innerHTML = `
                    <div class="product-header">
                        <strong>${product.name || product.product_name}</strong>
                    </div>
                    ${detailsHtml}
                `;

                button.onclick = () => selectProduct(product, index);
                selectionDiv.appendChild(button);
            });

            // Option pour rechercher d'autres produits (si applicable)
            if (data.allow_custom || data.allow_search) {
                const customButton = document.createElement('button');
                customButton.className = 'product-selection-button create-new';
                customButton.innerHTML = `
                    <i class="bi bi-search"></i> Rechercher un autre produit
                `;
                customButton.onclick = () => searchOtherProduct();
                selectionDiv.appendChild(customButton);
            }

            messagesContainer.appendChild(selectionDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Fonction pour s√©lectionner un produit
        function selectProduct(product, index) {
            const productName = product.name || product.product_name;
            addMessage(`Vous avez s√©lectionn√© : ${productName}`, 'user');

            // Utiliser le currentTaskId global
            const taskId = currentTaskId || window.currentTaskId;

            if (!taskId) {
                console.error("‚ùå Pas de task_id disponible pour la s√©lection de produit");
                addMessage("‚ùå Erreur: Session non initialis√©e. Veuillez r√©essayer.", 'system');
                return;
            }

            // V√©rifier l'√©tat du WebSocket
            const ws = websocket || window.websocket;

            if (ws && ws.readyState === WebSocket.OPEN) {
                const response = {
                    type: "user_response",
                    task_id: taskId,
                    data: {
                        response_type: "product_selection",
                        action: "select_product",
                        product_id: product.id,
                        product_name: productName,
                        selected_index: index,
                        selected_product: product
                    }
                };
                console.log("üì§ S√©lection produit avec task_id:", taskId, response);
                ws.send(JSON.stringify(response));

                // Afficher la progression
                showProgress();
            } else {
                console.error("‚ùå WebSocket non disponible pour la s√©lection de produit");
                addMessage("‚ùå Erreur de connexion. Veuillez r√©essayer.", 'system');
            }
        }

        // Fonction pour rechercher d'autres produits
        function searchOtherProduct() {
            addMessage("Recherche d'autres produits non impl√©ment√©e pour le moment.", 'system');
        }

        function handleUserInteraction(data) {
            console.log("ü§ù Interaction utilisateur requise:", data);

            if (data.interaction_type === 'client_selection') {
                const clients = data.client_options || data.options || data.clients || [];
                const originalName = data.original_client_name || data.client_name || '';
                addClientSelection(clients, originalName);
            } else {
                addMessage(`Interaction requise: ${data.interaction_type}`, 'system');
                console.warn("Type d'interaction non g√©r√©:", data);
            }
        }

        // Gestion progression
        function showProgress() {
            document.getElementById('progressContainer').classList.add('active');
        }

        function hideProgress() {
            document.getElementById('progressContainer').classList.remove('active');
        }

        function updateProgress(percentage, title, currentStep) {
            try {
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const stepText = document.getElementById('stepText');
                if (progressBar && progressText) {
                    progressBar.style.width = `${Math.min(percentage, 100)}%`;
                    progressText.textContent = `${Math.round(percentage)}%`;
                }
                
                if (stepText && title) {
                    stepText.textContent = title;
                }
                
                // Afficher le conteneur de progression s'il n'est pas visible
                if (percentage > 0 && !document.getElementById('progressContainer').classList.contains('active')) {
                    showProgress();
                }
                
                // Masquer √† 100% sauf si c'est une √©tape interm√©diaire
                if (percentage >= 100 && !title.includes("s√©lection") && !title.includes("interaction")) {
                    setTimeout(() => {
                        if (document.getElementById('progressContainer').classList.contains('active')) {
                            hideProgress();
                        }
                    }, 1000);
                }
            } catch (error) {
                console.error("Erreur updateProgress:", error);
            }
        }

        async function trackProgress(taskId) {
            if (!taskId) return;

            // Si un polling est d√©j√† en cours, on le stoppe
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }

            // Attendre 1.5 seconde avant de d√©marrer le polling (pour laisser le temps au backend)
            await new Promise(resolve => setTimeout(resolve, 1500));

            progressInterval = setInterval(async () => {
                try {
                    const response = await fetch(`/progress/task/${taskId}`);
                    if (!response.ok) {
                        // Ne pas afficher d'erreur imm√©diatement si c'est une 404
                        if (response.status === 404) {
                            console.log('T√¢che non trouv√©e, en attente de cr√©ation...');
                            return; // Continuer √† essayer
                        }

                        clearInterval(progressInterval);
                        progressInterval = null;
                        hideProgress();
                        handleTaskError(`Erreur serveur: ${response.status} ${response.statusText}`);
                        return;
                    }
                    const data = await response.json();

                    if (data.status === 'completed') {
                        clearInterval(progressInterval);
                        progressInterval = null;
                        hideProgress();
                        handleTaskComplete(data);
                    } else if (data.status === 'failed') {
                        clearInterval(progressInterval);
                        progressInterval = null;
                        hideProgress();
                        handleTaskError(data.error || data.message || 'T√¢che √©chou√©e');
                    } else {
                        updateProgress(
                            data.overall_progress || 0,
                            data.current_step_title || 'Traitement en cours...',
                            data.completed_steps || 0
                        );
                    }
                } catch (error) {
                    // Ne pas arr√™ter le polling pour les erreurs temporaires
                    console.error('Erreur temporaire suivi progression :', error);

                    // Si c'est une erreur r√©seau, continuer √† essayer quelques fois
                    if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        console.log('Erreur r√©seau, nouvelle tentative...');
                        return;
                    }

                    // Sinon, arr√™ter apr√®s trop d'erreurs
                    clearInterval(progressInterval);
                    progressInterval = null;
                    hideProgress();
                    handleTaskError('Erreur de connexion au serveur');
                }
            }, 1000);
        }
        

        // Enrichissement client
        function showEnrichment(clientData) {
            enrichmentData = clientData;
            const panel = document.getElementById('enrichmentPanel');
            const content = document.getElementById('enrichmentContent');
            
            let html = '';
            if (clientData.company_info) {
                html = `
                    <div class="enrichment-item">
                        <strong>Raison sociale:</strong>
                        <span>${clientData.company_info.name || 'Non trouv√©'}</span>
                    </div>
                    <div class="enrichment-item">
                        <strong>SIRET:</strong>
                        <span>${clientData.company_info.siret || 'Non trouv√©'}</span>
                    </div>
                    <div class="enrichment-item">
                        <strong>Adresse:</strong>
                        <span>${clientData.company_info.address || 'Non trouv√©e'}</span>
                    </div>
                    <div class="enrichment-item">
                        <strong>Secteur:</strong>
                        <span>${clientData.company_info.sector || 'Non d√©fini'}</span>
                    </div>
                `;
            } else {
                html = `
                    <div class="enrichment-item">
                        <strong>Nom du client:</strong>
                        <span>${clientData.name}</span>
                    </div>
                    <div class="enrichment-item">
                        <strong>Statut:</strong>
                        <span>Donn√©es enrichies non disponibles</span>
                    </div>
                `;
            }
            
            content.innerHTML = html;
            panel.classList.add('active');
        }

        function hideEnrichment() {
            document.getElementById('enrichmentPanel').classList.remove('active');
        }

        // Validation enrichissement avec v√©rifications suppl√©mentaires
        async function validateEnrichment() {
            if (!enrichmentData) {
                showValidationError('Aucune donn√©e d\'enrichissement disponible');
                return;
            }

            // V√©rifier les donn√©es minimales requises
            if (!enrichmentData.name && (!enrichmentData.company_info || !enrichmentData.company_info.name)) {
                showValidationError('Nom du client requis pour la validation');
                return;
            }

            try {
                showTyping();
                hideEnrichment();

                const response = await fetch('/api/assistant/workflow/create_client', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        client_data: enrichmentData,
                        validated: true
                    })
                });

                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }

                const result = await response.json();
                hideTyping();

                if (result.success) {
                    const clientName = enrichmentData.name || enrichmentData.company_info?.name || 'Client';
                    addMessage(`Client "${clientName}" cr√©√© avec succ√®s. Num√©ro: ${result.client_id}`, 'system');
                    continuePreviousWorkflow();
                } else {
                    addMessage(`Erreur lors de la cr√©ation du client: ${result.error || 'Erreur inconnue'}`, 'system');
                }
            } catch (error) {
                hideTyping();
                addMessage(`Erreur de connexion lors de la validation: ${error.message}`, 'system');
                console.error('Erreur validateEnrichment:', error);
            }
        }

        function editClientData() {
            addMessage('Fonctionnalit√© d\'√©dition en cours de d√©veloppement...', 'system');
        }

        // Gestion messages principaux
        function showTyping() {
            document.getElementById('typingIndicator').classList.add('active');
        }

        function hideTyping() {
            document.getElementById('typingIndicator').classList.remove('active');
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const errorDiv = document.getElementById('validationError');
            const message = (input?.value || '').trim();

            // Garde-fous UI et validation
            if (isProcessing) return;
            if (!message) return showValidationError('Le message est vide');
            if (message.length < 3) return showValidationError('Le message doit contenir au moins 3 caract√®res');
            if (message.length > 1000) return showValidationError('Le message ne peut pas d√©passer 1000 caract√®res');

            // D√©tection si c'est un devis avec nom de client
            const clientMatch = message.match(/devis.*pour\s+([A-Za-z\s]+?)(?:\s+pour|\s*$)/i);
            if (clientMatch) {
                const clientName = clientMatch[1].trim();

                // Recherche imm√©diate des clients
                try {
                    const searchResp = await fetch('/api/assistant/search_clients', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({client_name: clientName})
                    });

                    const searchResult = await searchResp.json();

                    if (searchResult.requires_selection) {
                        // Afficher le message de l'utilisateur
                        addMessage(message, 'user');
                        if (input) input.value = '';

                        // IMPORTANT: Cr√©er une t√¢che m√™me pour la s√©lection de client
                        isProcessing = true;
                        showTyping();

                        // Cr√©er la t√¢che avec le workflow normal
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 30000);

                            const resp = await fetch('/api/assistant/workflow/create_quote', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-Request-ID': generateUUID(),
                                },
                                body: JSON.stringify({
                                    message,
                                    draft_mode: false,
                                    client_search_result: searchResult // Inclure le r√©sultat de recherche
                                }),
                                signal: controller.signal
                            });

                            clearTimeout(timeoutId);

                            if (!resp.ok) {
                                throw new Error(`HTTP ${resp.status}`);
                            }

                            const result = await resp.json();
                            hideTyping();

                            if (result?.task_id) {
                                currentTaskId = result.task_id;
                                window.currentTaskId = result.task_id; // S'assurer que c'est global

                                // Connecter le WebSocket AVANT d'afficher la s√©lection
                                connectWebSocket(result.task_id);

                                // Attendre un peu que le WebSocket soit connect√©
                                setTimeout(() => {
                                    addClientSelection(searchResult.clients, clientName);
                                }, 500);
                            }
                        } catch (error) {
                            hideTyping();
                            isProcessing = false;
                            console.error('Erreur cr√©ation t√¢che:', error);
                            addMessage('‚ùå Erreur lors de la cr√©ation de la t√¢che', 'system');
                        }

                        return;
                    }
                } catch (e) {
                    console.error('Erreur recherche client:', e);
                }
            }

            // Continuer avec le flux normal pour les autres cas
            isProcessing = true;
            if (errorDiv) errorDiv.style.display = 'none';
            addMessage(message, 'user');
            if (input) input.value = '';
            updateSendButton();
            autoResize();
            showTyping();

            try {
                // Cr√©er un contr√¥leur d'annulation avec timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 secondes de timeout

                const resp = await fetch('/api/assistant/workflow/create_quote', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Request-ID': generateUUID(),
                    },
                    body: JSON.stringify({ message, draft_mode: false }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                // Gestion des erreurs HTTP
                if (!resp.ok) {
                    let details = '';
                    const text = await resp.text();
                    try {
                        const errJson = JSON.parse(text);
                        details = errJson?.error || text;
                    } catch (e) {
                        details = text;
                    }
                    throw new Error(`HTTP ${resp.status} ‚Äî ${details}`);
                }

                const result = await resp.json();
                hideTyping();

                if (result?.task_id) {
                    currentTaskId = result.task_id;
                    showProgress();
                    // Attendre que la t√¢che soit cr√©√©e c√¥t√© serveur
                    setTimeout(() => {
                        connectWebSocket(result.task_id);
                        trackProgress(result.task_id);
                    }, 1500);
                } else {
                    handleDirectResponse(result);
                }

            } catch (error) {
                hideTyping();
                console.error('Erreur sendMessage:', error);

                // Analyser le type d'erreur pour un message plus clair
                let errorMessage = 'Erreur de connexion';
                if (error.message) {
                    if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
                        errorMessage = 'Impossible de contacter le serveur. V√©rifiez votre connexion.';
                    } else if (error.message.includes('404')) {
                        errorMessage = 'Service non disponible. Contactez l\'administrateur.';
                    } else if (error.message.includes('500')) {
                        errorMessage = 'Erreur serveur. Veuillez r√©essayer plus tard.';
                    } else if (error.message.includes('HTTP')) {
                        errorMessage = error.message;
                    } else {
                        errorMessage = `Erreur: ${error.message}`;
                    }
                }

                addMessage(`‚ùå ${errorMessage}`, 'system');
            } finally {
                isProcessing = false;
                updateSendButton();
                input?.focus();
            }
        }



        function handleDirectResponse(result) {
            if (result.status === 'client_creation_required') {
                addMessage(`Client "${result.client_name}" non trouv√©. Recherche d'informations...`, 'system');

                setTimeout(() => {
                    const enrichedData = {
                        name: result.client_name,
                        company_info: {
                            name: result.client_name.toUpperCase() + ' SARL',
                            siret: '12345678901234',
                            address: '1 Rue du Commerce, 75001 Paris',
                            sector: 'Services informatiques'
                        }
                    };

                    addMessage(`Donn√©es enrichies trouv√©es automatiquement:`, 'system');
                    showEnrichment(enrichedData);
                }, 1500);

            } else if (result.status === 'client_selection_required') {
                const clients = result.clients || [];
                const originalName = result.original_client_name || result.client_name || '';
                addClientSelection(clients, originalName);
            } else if (result.status === 'success') {
                handleTaskComplete(result);
            } else {
                addMessage(`${result.message || 'R√©ponse re√ßue'}`, 'system');
            }
        }

        function handleTaskComplete(result) {
            if (result.status === 'success') {
                addMessage(`Devis cr√©√© avec succ√®s !`, 'system');
                addMessage(`ID: ${result.quote_id}`, 'system');
                addMessage(`Client: ${result.client.name}`, 'system');
                addMessage(`Montant: ${result.total_amount}‚Ç¨`, 'system');
                
                const suggestions = ['Voir le devis', 'Cr√©er un nouveau devis', 'Modifier le devis'];
                addSuggestions(suggestions);
            } else {
                addMessage(`Erreur: ${result.error || 'Erreur inconnue'}`, 'system');
            }
        }

        function handleTaskError(error) {
            hideProgress();
            // Am√©liorer le message d'erreur avec plus de d√©tails
            let errorMsg = 'Une erreur inattendue est survenue lors du traitement';

            if (error) {
                if (typeof error === 'string') {
                    errorMsg = error;
                } else if (error.message) {
                    errorMsg = error.message;
                } else if (error.error) {
                    errorMsg = error.error;
                } else if (error.detail) {
                    errorMsg = error.detail;
                } else {
                    // Si l'erreur est un objet, essayons de le convertir en string
                    try {
                        errorMsg = JSON.stringify(error);
                    } catch (e) {
                        errorMsg = 'Erreur complexe non identifiable';
                    }
                }
            }

            // √âviter d'afficher "Erreur: Erreur inconnue"
            if (errorMsg === 'Erreur inconnue' || errorMsg === 'null' || errorMsg === 'undefined') {
                errorMsg = 'Le serveur ne r√©pond pas correctement. Veuillez r√©essayer.';
            }

            addMessage(`‚ùå Erreur: ${errorMsg}`, 'system');
            console.error("Erreur de t√¢che:", error);
            isProcessing = false;
            updateSendButton();

            // Fermer le WebSocket en cas d'erreur
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.close();
            }
        }

        function continuePreviousWorkflow() {
            addMessage('Reprise de la g√©n√©ration du devis...', 'system');
        }

        // Gestion entr√©es et formulaire
        async function handleFormSubmit(event) {
            console.log("üìã handleFormSubmit appel√©");
            event.preventDefault();

            const input = document.getElementById('chatInput');
            const message = input.value.trim();

            console.log("üìã Message:", message, "length:", message.length, "isProcessing:", isProcessing);

            // Validation c√¥t√© client
            if (!message) {
                showValidationError('Veuillez saisir un message');
                return false;
            }

            if (message.length < 3) {
                showValidationError('Le message doit contenir au moins 3 caract√®res');
                return false;
            }

            if (message.length > 1000) {
                showValidationError('Le message ne peut pas d√©passer 1000 caract√®res');
                return false;
            }

            if (isProcessing) {
                showValidationError('Traitement en cours, veuillez patienter...');
                return false;
            }

            // Si validation OK, envoyer le message
            await sendMessage();
            return false;
        }
        
        function showValidationError(message) {
            // Cr√©er ou mettre √† jour le message d'erreur
            let errorDiv = document.getElementById('validationError');
            if (!errorDiv) {
            errorDiv = document.createElement('div');
            errorDiv.id = 'validationError';
            errorDiv.className = 'validation-error';
            errorDiv.style.cssText = `
            color: var(--warning-color);
            font-size: 0.875rem;
            margin-top: 8px;
            padding: 8px 12px;
            background-color: rgba(253, 82, 2, 0.1);
            border: 1px solid var(--warning-color);
            border-radius: 4px;
            display: none;
            `;
            document.getElementById('chatForm').appendChild(errorDiv);
            }
            
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            // Masquer l'erreur apr√®s 3 secondes
            setTimeout(() => {
            errorDiv.style.display = 'none';
            }, 3000);
        }
        
        function handleInput() {
            updateSendButton();
            autoResize();
        
            // Masquer l'erreur de validation si elle existe
            const errorDiv = document.getElementById('validationError');
            if (errorDiv) {
            errorDiv.style.display = 'none';
            }
        }
        
        // Fonction de gestion des touches pour le chat
        function handleKeyPress(event) {
            console.log("‚å®Ô∏è Touche press√©e:", event.key, "shiftKey:", event.shiftKey);
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                const form = document.getElementById('chatForm');
                const button = document.getElementById('sendButton');

                console.log("‚å®Ô∏è √âtat actuel - isProcessing:", isProcessing, "button disabled:", button?.disabled);

                // Si le bouton n'est pas d√©sactiv√©, envoyer le message
                if (button && !button.disabled) {
                    console.log("‚å®Ô∏è Envoi via Enter");
                    if (form) {
                        form.requestSubmit(); // Utiliser requestSubmit pour d√©clencher l'√©v√©nement submit
                    } else {
                        // Fallback : appeler directement sendMessage
                        sendMessage();
                    }
                } else {
                    console.log("‚å®Ô∏è Bouton d√©sactiv√©, pas d'envoi");
                    showValidationError('Veuillez entrer un message valide (3 caract√®res minimum)');
                }
            }
        }

        function updateSendButton() {
            const input = document.getElementById('chatInput');
            const button = document.getElementById('sendButton');

            if (!input || !button) {
                console.error("‚ùå √âl√©ments du formulaire non trouv√©s");
                return;
            }

            const message = input.value.trim();

            // D√©sactiver le bouton si :
            // - Pas de message ou message trop court
            // - Message trop long
            // - Traitement en cours
            const shouldDisable = !message || message.length < 3 || message.length > 1000 || isProcessing;

            console.log("[updateSendButton] isProcessing:", isProcessing, "| value:", input.value, "| trim:", message, "| len:", message.length, "| disabled sera:", shouldDisable);

            button.disabled = shouldDisable;

            // Changer le style du bouton selon son √©tat
            if (shouldDisable) {
                button.style.opacity = '0.5';
                button.style.cursor = 'not-allowed';
            } else {
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            }
        }

        function autoResize() {
            const input = document.getElementById('chatInput');
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 100) + 'px';
        }

        // Gestion connexion
        async function checkConnection() {
            try {
                // Ajouter un timeout pour √©viter d'attendre trop longtemps
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 secondes

                const response = await fetch('/health', {
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                const statusEl = document.getElementById('connectionStatus');
                if (data.status === 'healthy') {
                    statusEl.className = 'connection-status connected';
                    statusEl.innerHTML = '<i class="bi bi-wifi"></i> Connect√©';
                } else {
                    statusEl.className = 'connection-status disconnected';
                    statusEl.innerHTML = '<i class="bi bi-wifi-off"></i> D√©connect√©';
                }
            } catch (error) {
                const statusEl = document.getElementById('connectionStatus');
                statusEl.className = 'connection-status disconnected';

                if (error.name === 'AbortError') {
                    statusEl.innerHTML = '<i class="bi bi-wifi-off"></i> Timeout';
                } else {
                    statusEl.innerHTML = '<i class="bi bi-wifi-off"></i> Hors ligne';
                }

                console.warn('V√©rification connexion √©chou√©e:', error.message);
                // D√©tail de l'erreur pour le d√©bogage
                console.error('D√©tails erreur connexion:', {
                message: error.message,
                name: error.name,
                stack: error.stack
                });
            }
        }
        // Fonction pour mettre √† jour l'indicateur de statut de connexion
        function updateConnectionStatus(status, message) {
            const statusEl = document.getElementById('connectionStatus');
            if (statusEl) {
                if (status === 'connected') {
                    statusEl.className = 'connection-status connected';
                    statusEl.innerHTML = '<i class="bi bi-wifi"></i> Connect√©';
                } else if (status === 'disconnected') {
                    statusEl.className = 'connection-status disconnected';
                    statusEl.innerHTML = '<i class="bi bi-wifi-off"></i> D√©connect√©';
                } else {
                    statusEl.className = 'connection-status disconnected';
                    statusEl.innerHTML = '<i class="bi bi-wifi-off"></i> Erreur';
                }
                console.log(`üì° Statut connexion: ${status} - ${message}`);
            }
        }
        // Connexion WebSocket
        function connectWebSocket(taskId) {
            
            // Fermer toute connexion existante avant d'en cr√©er une nouvelle
            if (window.websocket) {
                if (window.websocket.readyState === WebSocket.OPEN || window.websocket.readyState === WebSocket.CONNECTING) {
                    console.log("üîÑ Fermeture de la connexion WebSocket existante");
                    window.websocket.close();
                }
                window.websocket = null;
            }

            const wsProtocol = window.location.protocol === "https:" ? "wss" : "ws";
            const wsUrl = `${wsProtocol}://${window.location.host}/ws/task/${taskId}`;

            console.log(`üîå Tentative de connexion √† ${wsUrl}`);
            // Variables pour le heartbeat
            let heartbeatInterval = null;
            try {
                window.websocket = new WebSocket(wsUrl);
            } catch (error) {
                console.error("‚ùå Impossible de cr√©er la connexion WebSocket:", error);
                if (typeof handleTaskError === "function") {
                    handleTaskError("Impossible d'√©tablir la connexion temps r√©el");
                }
                return;
            }

            const websocket = window.websocket; // alias local

            websocket.onopen = () => {
                console.log("‚úÖ WebSocket connect√© !");
                if (typeof updateConnectionStatus === "function") {
                    updateConnectionStatus("connected", "WebSocket connect√©");
                }
                // D√©marrer le heartbeat pour maintenir la connexion
                heartbeatInterval = setInterval(() => {
                    if (websocket.readyState === WebSocket.OPEN) {
                        websocket.send(JSON.stringify({ type: "ping" }));
                    }
                }, 30000); // Ping toutes les 30 secondes
                if (window.reconnectInterval) {
                    clearInterval(window.reconnectInterval);
                    window.reconnectInterval = null;
                }
            };

            websocket.onmessage = (event) => {
                let data;
                try {
                    data = JSON.parse(event.data);
                } catch (error) {
                    console.error("Erreur parsing message WebSocket:", error);
                    return;
                }

                console.log("üì• Message re√ßu:", data);

                // V√©rifier d'abord si c'est un message task_update avec interaction_data
                if (data.type === "task_update" && data.interaction_data) {
                    if (data.interaction_data.interaction_type === 'client_selection') {
                        console.log("üéØ Client selection via task_update d√©tect√©");
                        hideProgress();
                        const opts = data.interaction_data.client_options || data.interaction_data.options || data.interaction_data.clients || [];
                        const name = data.interaction_data.original_client_name || data.interaction_data.client_name || '';
                        console.log(`üéØ Affichage s√©lection client: ${opts.length} options pour "${name}"`);
                        addClientSelection(opts, name);
                        return;
                    } else if (data.interaction_data.interaction_type === 'product_selection') {
                        console.log("üì¶ Product selection via task_update d√©tect√©");
                        hideProgress();
                        if (typeof handleProductSelection === "function") {
                            handleProductSelection(data.interaction_data);
                        }
                        return;
                    }
                }

                // Gestion des messages progress_update et initial_progress
                switch (data.type) {
                    case "initial_progress": {
                        console.log("üìä Initial progress re√ßu:", data);
                        if (data.data) {
                            const progress = data.data;
                            if (progress.current_step && progress.progress !== undefined) {
                                updateProgress(progress.progress, progress.current_step.message || "Initialisation...", progress.current_step.id);
                            }
                        }
                        break;
                    }
                    case "progress_update": {
                        console.log("üîÑ Progress update re√ßu:", data);
                        if (data.progress !== undefined) {
                            updateProgress(data.progress, data.message || "Traitement en cours...", data.step_id);
                        }
                        break;
                    }

                    case "progress": {
                        const container = document.getElementById("progressContainer");
                        if (container && !container.classList.contains("active") && typeof showProgress === "function") {
                            showProgress();
                        }
                        if (typeof updateProgress === "function") {
                            updateProgress(data.progress, data.message, data.step);
                        }
                        break;
                    }

                    case "interaction_required": {
                        if (typeof handleUserInteraction === "function") {
                            handleUserInteraction(data.data);
                        }
                        // on garde la connexion ouverte
                        break;
                    }

                    case "client_selection_required": {
                        if (data.interaction_data && data.interaction_data.interaction_type === 'client_selection') {
                            if (typeof hideProgress === "function") hideProgress();
                            const opts = data.interaction_data.client_options || data.interaction_data.options || data.interaction_data.clients || [];
                            const name = data.interaction_data.original_client_name || data.interaction_data.client_name || '';
                            console.log(`üéØ Affichage s√©lection client: ${opts.length} options pour "${name}"`);
                            if (typeof addClientSelection === "function") {
                                addClientSelection(opts, name);
                            }
                        }
                        break;
                    }

                    case "user_interaction_required": {
                        console.log("ü§ù Interaction utilisateur d√©tect√©e:", data.interaction_data || "Aucune donn√©e d'interaction disponible");
                        if (data.interaction_data && data.interaction_data.interaction_type === 'client_selection') {
                            if (typeof hideProgress === "function") hideProgress();
                            const opts = data.interaction_data.client_options || data.interaction_data.options || data.interaction_data.clients || [];
                            const name = data.interaction_data.original_client_name || data.interaction_data.client_name || '';
                            console.log(`üéØ Affichage s√©lection client: ${opts.length} options pour "${name}"`);
                            if (typeof addClientSelection === "function") addClientSelection(opts, name);
                        } else if (data.interaction_data && data.interaction_data.interaction_type === 'product_selection') {
                            if (typeof hideProgress === "function") hideProgress();
                            if (typeof handleProductSelection === "function") {
                                handleProductSelection(data.interaction_data);
                            }
                        } else {
                            console.warn("Type d'interaction non g√©r√©:", data.interaction_data);
                            if (typeof handleUserInteraction === "function") {
                                handleUserInteraction(data.interaction_data);
                            }
                        }
                        break;
                    }

                    case "task_update": {
                        console.log("üîÑ Task update re√ßu:", data);
                        // G√©rer sp√©cifiquement les task_update avec interaction_data
                        if (data.interaction_data && data.interaction_data.interaction_type === 'client_selection') {
                            console.log("üéØ Client selection via task_update d√©tect√©");
                            if (typeof hideProgress === "function") hideProgress();
                            const opts = data.interaction_data.client_options || data.interaction_data.options || data.interaction_data.clients || [];
                            const name = data.interaction_data.original_client_name || data.interaction_data.client_name || '';
                            console.log(`üéØ Affichage s√©lection client: ${opts.length} options pour "${name}"`);
                            if (typeof addClientSelection === "function") addClientSelection(opts, name);
                        } else if (data.interaction_data && data.interaction_data.interaction_type === 'product_selection') {
                            console.log("üì¶ Product selection via task_update d√©tect√©");
                            if (typeof hideProgress === "function") hideProgress();
                            if (typeof handleProductSelection === "function") {
                                handleProductSelection(data.interaction_data);
                            }
                        }
                        break;
                    }

                    case "completion": {
                        if (window.progressInterval) {
                            clearInterval(window.progressInterval);
                            window.progressInterval = null;
                        }
                        if (typeof handleTaskComplete === "function") {
                            handleTaskComplete(data.data);
                        }
                        try { websocket.close(1000, "Task completed"); } catch (_) {}
                        break;
                    }

                    case "error": {
                        if (window.progressInterval) {
                            clearInterval(window.progressInterval);
                            window.progressInterval = null;
                        }
                        if (typeof handleTaskError === "function") {
                            handleTaskError(data.error || data.message || data);
                        }
                        try { websocket.close(1011, "Task error"); } catch (_) {}
                        break;
                    }

                    case "log": {
                        if (typeof addMessage === "function") addMessage(`[LOG] ${data.message}`, "system");
                        break;
                    }

                    case "message": {
                        if (typeof addMessage === "function") addMessage(data.message, "system");
                        break;
                    }
                    case 'quote_generation_completed':
                        updateProgress('‚úÖ Devis g√©n√©r√© avec succ√®s', 100);
                        displayFinalQuoteResult(data.result);
                        break;
                    default: {
                        console.warn("Type de message non g√©r√©:", data.type);
                        console.log("Donn√©es compl√®tes:", data);
                    }
                }
            };

            websocket.onclose = (event) => {
                console.warn(`üîå WebSocket d√©connect√©. Code: ${event.code}, Raison: ${event.reason}`);
                // Arr√™ter le heartbeat
                if (heartbeatInterval) {
                    clearInterval(heartbeatInterval);
                    heartbeatInterval = null;
                }
                console.log(`üîå WebSocket d√©connect√©. Code: ${event.code}, Raison: ${event.reason}`);
                window.websocket = null;

                // Fermetures normales: ne rien faire
                if (event.code === 1000 || event.code === 1001) {
                    if (typeof updateConnectionStatus === "function") {
                        updateConnectionStatus("disconnected", "Connexion ferm√©e");
                    }
                    return;
                }

                // 1006 = d√©connexion anormale (r√©seau). Si pas en traitement, juste marquer d√©connect√©.
                if (event.code === 1006 && !window.isProcessing) {
                    if (typeof updateConnectionStatus === "function") {
                        updateConnectionStatus("disconnected", "Connexion perdue");
                    }
                    return;
                }

                // Si on traite encore, tenter une reconnexion
                if (window.isProcessing && window.currentTaskId) {
                    if (typeof addMessage === "function") {
                        addMessage("La connexion a √©t√© perdue. Tentative de reconnexion...", "system");
                    }
                    if (typeof attemptReconnection === "function") {
                        attemptReconnection(window.currentTaskId);
                    }
                }
            };

            websocket.onerror = (err) => {
                console.error("üå©Ô∏è Erreur WebSocket:", err);
                // L'onclose g√®rera l'√©tat/reco; on √©vite les doublons ici.
            };

            // Optionnel : v√©rification diff√©r√©e d'√©ventuelles validations en attente
            function checkPendingValidations(id) {
                // TODO: impl√©menter si n√©cessaire
                void id; // no-op pour √©viter l'avertissement
            }
            setTimeout(() => checkPendingValidations(taskId), 1000);
        }



        // Fonction de tentative de reconnexion WebSocket avec limitation
        function attemptReconnection(taskId) {
            if (reconnectInterval) return;

            // Si on n'est plus en train de traiter, ne pas reconnecter
            if (!isProcessing || !currentTaskId) {
                console.log("Pas de reconnexion - traitement termin√©");
                return;
            }

            let attempts = 0;
            const maxAttempts = 3; // R√©duire √† 3 tentatives

            reconnectInterval = setInterval(() => {
                attempts++;
                console.log(`üîÑ Tentative reconnexion ${attempts}/${maxAttempts}`);
                updateConnectionStatus('disconnected', `Reconnexion ${attempts}/${maxAttempts}`);

                if (attempts >= maxAttempts) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                    updateConnectionStatus('disconnected', 'Connexion √©chou√©e');
                    console.log("‚ùå Abandon reconnexion WebSocket");

                    // Informer l'utilisateur
                    addMessage("‚ùå Impossible de maintenir la connexion. Veuillez rafra√Æchir la page si le probl√®me persiste.", 'system');

                    // Arr√™ter le traitement
                    isProcessing = false;
                    hideProgress();
                    updateSendButton();
                    return;
                }

                connectWebSocket(taskId);
            }, 3000);
        }
        

        // Initialisation au chargement de la page, une seule fois !
        document.addEventListener('DOMContentLoaded', function () {
            const input = document.getElementById('chatInput');
            const form = document.getElementById('chatForm');
            const errorDiv = document.getElementById('validationError');

            // √âcouteur de validation formulaire sur submit
            if (form) {
                form.addEventListener('submit', handleFormSubmit);

                // Validation du formulaire en temps r√©el (input sur le champ de saisie)
                form.addEventListener('input', function (e) {
                    if (e.target.id === 'chatInput') {
                        const message = e.target.value.trim();
                        if (message.length > 1000) {
                            showValidationError('Message trop long (maximum 1000 caract√®res)');
                        } else if (errorDiv) {
                            errorDiv.style.display = 'none';
                        }
                    }
                });
            }

            // √âcouteur sur input pour gestion de l'envoi par clavier
            if (input) {
                input.addEventListener('keydown', handleKeyPress);
                input.addEventListener('input', handleInput);
                input.focus();
            }

            // Ajouter un event listener de secours sur le bouton
            const sendBtn = document.getElementById('sendButton');
            if (sendBtn) {
                sendBtn.addEventListener('click', function(e) {
                    console.log("üîò Bouton cliqu√© directement");
                    if (!sendBtn.disabled) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
            }

            // V√©rification de la connexion WebSocket r√©guli√®re
            checkConnection();
            setInterval(checkConnection, 30000);

            // R√©initialiser l'√©tat au cas o√π
            isProcessing = false;
            updateSendButton();

            // Debug - v√©rifier l'√©tat initial
            console.log("üöÄ Initialisation termin√©e - isProcessing:", isProcessing);
            console.log("üöÄ √âtat du bouton:", document.getElementById('sendButton').disabled);
        });

        // √âcouter toute soumission de formulaire pour d√©tecter un nouveau task_id
        document.addEventListener('submit', function (e) {
            if (e.target.id === 'chatForm') {
                // handleFormSubmit g√®re la logique principale
                return;
            }

            if (e.target.closest('.input-container')) {
                setTimeout(() => {
                    const messagesContainer = document.getElementById('chatMessages');
                    if (messagesContainer) {
                        // Cherche un task_id dans le dernier message
                        const lastMessages = messagesContainer.querySelectorAll('.message');
                        if (lastMessages.length > 0) {
                            const lastMessage = lastMessages[lastMessages.length - 1];
                            const taskIdMatch = lastMessage.textContent.match(/quote_\d{8}_\d{6}_\w+/);
                            if (taskIdMatch) {
                                const taskId = taskIdMatch[0];
                                console.log("üéØ Task ID d√©tect√©:", taskId);
                                connectWebSocket(taskId);
                            } else {
                                console.log("‚ö†Ô∏è Aucun task_id d√©tect√© dans le dernier message.");
                            }
                        } else {
                            console.log("‚ö†Ô∏è Aucun message trouv√© dans le container.");
                        }
                    } else {
                        console.log("‚ö†Ô∏è Container des messages introuvable.");
                    }
                }, 1000);
            }
        });
        function displayFinalQuoteResult(result) {
            try {
                const container = document.getElementById('progress-container');
                
                const resultHtml = `
                    <div class="quote-result-success">
                        <h3>‚úÖ Devis cr√©√© avec succ√®s</h3>
                        <div class="quote-details">
                            <div class="quote-info">
                                <strong>Num√©ro de devis SAP :</strong> ${result.sap_doc_num || 'N/A'}<br>
                                <strong>Opportunit√© Salesforce :</strong> ${result.salesforce_opportunity_id || 'N/A'}<br>
                                <strong>Client :</strong> ${result.client?.name || 'N/A'}<br>
                                <strong>Montant total :</strong> ${result.total_amount || 0}‚Ç¨
                            </div>
                            <div class="products-list">
                                <h4>Produits inclus :</h4>
                                ${result.products?.map(p => `<div>‚Ä¢ ${p.name} x${p.quantity} - ${p.unit_price}‚Ç¨</div>`).join('') || 'Aucun produit'}
                            </div>
                        </div>
                        <div class="quote-actions">
                            <button onclick="resetInterface()" class="btn btn-primary">Nouveau devis</button>
                        </div>
                    </div>
                `;
                
                container.innerHTML = resultHtml;
            } catch (error) {
                console.error('Erreur affichage r√©sultat:', error);
            }
        }
    </script>
</body>
</html>
